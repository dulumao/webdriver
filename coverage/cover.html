
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/webdriver/chrome.go (100.0%)</option>
				
				<option value="file1">github.com/webdriver/tcp.go (100.0%)</option>
				
				<option value="file2">github.com/webdriver/wire.go (100.0%)</option>
				
				<option value="file3">github.com/webdriver/wire_http.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" >package webdriver

import (
  "fmt"
  "os"
  "os/exec"
  "time"
)

type (

  Chrome struct {
    AdbPort int
    Host string
    LogPath string
    PathExec string
    Port int
    PortServer string
    Process *os.Process
    RemoveOnClose string
    Silent bool
    Timeout float64
    UrlBase string
    Verbose bool
    WhiteList string

    *Wire

  }

)

// Sets the default values for a Client.  Chrome struct includes
// an anonymous Client struct that is initialized in this method.
func (s *Chrome) SetDefaults() (err error) <span class="cov8" title="1">{
  if s.Host == "" </span><span class="cov8" title="1">{s.Host = "localhost"}</span>
  <span class="cov8" title="1">if s.PathExec == "" </span><span class="cov8" title="1">{s.PathExec = "chromedriver"}</span>
  <span class="cov8" title="1">if s.Port == 0 </span><span class="cov8" title="1">{s.Port = 9515}</span>
  <span class="cov8" title="1">if s.Timeout == 0 </span><span class="cov8" title="1">{s.Timeout = 60}</span>

  <span class="cov8" title="1">s.Wire = &amp;Wire{}

  return err</span>
}

// ChromeDriver 2.14.313457 (3d645c400edf2e2c500566c9aa096063e707c9cf)
//
// Options
//   --port=PORT                     port to listen on
//   --adb-port=PORT                 adb server port
//   --log-path=FILE                 write server log to file instead of stderr, increases log level to INFO
//   --verbose                       log verbosely
//   --version                       print the version number and exit
//   --silent                        log nothing
//   --url-base                      base URL path prefix for commands, e.g. wd/url
//   --port-server                   address of server to contact for reserving a port
//   --whitelisted-ips               comma-separated whitelist of remote IPv4 addresses which are allowed to connect to ChromeDriver
//
func (s *Chrome) Run() (err error) <span class="cov8" title="1">{

  if err = s.SetDefaults(); err == nil </span><span class="cov8" title="1">{

    options := s.buildOptions()

    cmd := exec.Command(s.PathExec, options...)

    cmd.Start()

    s.Process = cmd.Process

    // shouldn't make a difference if UrlBase is blank or not
    s.BaseUrl = fmt.Sprintf("http://%v:%v%v", s.Host, s.Port, s.UrlBase)

    err = waitForConnect(s.Host, s.Port, s.Timeout * float64(time.Second))

  }</span>

  <span class="cov8" title="1">return err</span>
}

func (s *Chrome) buildOptions() (options []string) <span class="cov8" title="1">{

  if s.AdbPort &gt; 0 </span><span class="cov8" title="1">{
    options = append(options, fmt.Sprintf("-adb-port=%d", s.AdbPort))
  }</span>

  <span class="cov8" title="1">if s.LogPath != "" </span><span class="cov8" title="1">{
    options = append(options, fmt.Sprintf("-log-path=%v", s.LogPath))
  }</span>

  <span class="cov8" title="1">if s.Port &gt; 0 </span><span class="cov8" title="1">{
    options = append(options, fmt.Sprintf("-port=%d", s.Port))
  }</span>

  <span class="cov8" title="1">if s.PortServer != "" </span><span class="cov8" title="1">{
    options = append(options, fmt.Sprintf("-port-server=%v", s.PortServer))
  }</span>

  <span class="cov8" title="1">if s.Silent </span><span class="cov8" title="1">{
    options = append(options, "--silent")
  }</span>

  <span class="cov8" title="1">if s.UrlBase != "" </span><span class="cov8" title="1">{
    options = append(options, fmt.Sprintf("-url-base=%v", s.UrlBase))
  }</span>

  <span class="cov8" title="1">if s.Verbose </span><span class="cov8" title="1">{
    options = append(options, "--verbose")
  }</span>

  <span class="cov8" title="1">if s.WhiteList != "" </span><span class="cov8" title="1">{
    options = append(options, fmt.Sprintf("-whitelisted-ips=%v", s.WhiteList))
  }</span>

  <span class="cov8" title="1">return options</span>
}

// TODO Figure out how to shutdown the browser as well as the webdriver
// currently, it seems like just the webdriver is being shutdown
// Kills the currently running webdriver if it is running.
func (s *Chrome) Close() (err error) <span class="cov8" title="1">{

  if s.Process != nil </span><span class="cov8" title="1">{

    s.CloseSessions()

    s.Process.Kill()
  }</span>

  <span class="cov8" title="1">return err</span>
}

func (s *Chrome) GetSessions() ([]*Session) <span class="cov8" title="1">{
  return s.Sessions
}</span>
























</pre>
		
		<pre class="file" id="file1" style="display: none">package webdriver

import (
  "errors"
  "fmt"
  "net"
  "time"
)

// Waits until a tcp connection can be made to a server
// or until the timeout has been exceeded.
func waitForConnect(host string, port int, timeout float64) (err error) <span class="cov8" title="1">{

  began := time.Now()

  address := fmt.Sprintf("%v:%d", host, port)

  for </span><span class="cov8" title="1">{

    // try to connect to the host/port
    if connection, err := net.Dial("tcp", address); err == nil </span><span class="cov8" title="1">{

      err = connection.Close()
      break</span>

    }

    <span class="cov8" title="1">time.Sleep(1 * time.Second)

    // making it here means the lock failed and err is not nil
    // that can and will happen and we should try again unless the timeout
    // period has expired
    if float64(time.Since(began)) &gt; timeout </span><span class="cov8" title="1">{
      return errors.New("waitForConnect() =&gt; timeout expired waiting to connect")
    }</span>

  }

  <span class="cov8" title="1">return err</span>
}

func waitForLock(host string, port int, timeout float64) (listener net.Listener, err error) <span class="cov8" title="1">{

  began := time.Now()

  address := fmt.Sprintf("%v:%d", host, port)

  for </span><span class="cov8" title="1">{

    // try to lock the port by listening on it
    if listener, err := net.Listen("tcp", address); err == nil </span><span class="cov8" title="1">{
      // if no error, then, it must be listening and is considered locked
      return listener, nil
    }</span>

    <span class="cov8" title="1">time.Sleep(1 * time.Second)

    // making it here means the lock failed and err is not nil
    // that can and will happen and we should try again unless the timeout
    // period has expired
    if float64(time.Since(began)) &gt; timeout </span><span class="cov8" title="1">{
      err = errors.New("WaitForLock() =&gt; timeout expired trying to lock mutex port")
      break</span>
    }

  }

  <span class="cov8" title="1">return nil, err</span>
}

func findNextAvailablePort(host string, port int, timeout float64) (newPort int, err error) <span class="cov8" title="1">{

  newPort = 0

  if port &gt; 0 </span><span class="cov8" title="1">{

    began := time.Now()

    // the current value of the client.Port is considered the desired port
    // however, we need to find the next available port for use,
    // therefore, i uses the current desired port as a starting point
    for i := port; i &lt; 65535; i++ </span><span class="cov8" title="1">{

      address := fmt.Sprintf("%v:%d", host, i)

      // try to lock the port by listening on it
      if listener, err := net.Listen("tcp", address); err == nil </span><span class="cov8" title="1">{

        // assign the port and close
        newPort = i

        // no need to defer here
        listener.Close()

        // if no error, then, it must be listening and is considered locked
        break</span>
      }

      <span class="cov8" title="1">time.Sleep(1 * time.Second)

      // making it here means the lock failed and err is not nil
      // that can and will happen and we should try again unless the timeout
      // period has expired
      if float64(time.Since(began)) &gt; timeout </span><span class="cov8" title="1">{
        err = errors.New("findNextAvailablePort() =&gt; timeout expired while determining next available port")
        break</span>
      }

    }

  }<span class="cov8" title="1"> else {
    err = errors.New(fmt.Sprintf("findNextAvailablePort() =&gt; Port needs to be set: ", port))
  }</span>

  <span class="cov8" title="1">return newPort, err</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package webdriver

import (
  "bytes"
  "encoding/json"
  "fmt"
  "net/http"
  "strings"
)

type (

  // used primarilty as a convenience to construct maps being passed
  // to the http get, post, methods.
  Params map[string]interface{}

  Session struct {

    ActualCapabilities *ActualCapabilities

    *Wire

  }

  // Represents all of the data and methods for the JsonWireProtocol API.
  // Include this in your client and make API calls.
  //
  // All JsonWireProtocol commands are attached to this struct.
  Wire struct {

    // a url pointing to a running server supporting the JsonWireProtocol.
    // typically, http://localhost:7055 for firefox.
    BaseUrl string

    // represents the most recent error
    Error error

    Response *WireResponse

    // represents a JsonWireProtocol Session ID.
    // The Session struct includes *WireHTTP, so, SessionID is available
    // to individual sessions.
    //
    // Most of the JsonWireProtocol API calls require a session id.
    // Only a couple do not.  GetFullUrl() will search for :sessionid
    // and replace it with SessionID during API calls.
    //
    // By default, SessionID is "", so, there should be no impact
    // for API calls that do not require a :sessionid
    SessionID string

    Sessions []*Session

  }

)

// Builds a complete url for a request including host and port.
// Relies on the current value of BaseUrl and SessionID.
//
//   // given:
//     BaseUrl = "http://localhost:7055"
//     SessionID = "my-session-id"
//
//   // the following call
//   BuildFullUrl("/session/:sessionid/forward")
//
//   // would produce
//   http://localhost:7055/session/my-session-id/forward
//
func (s *Wire) BuildFullUrl(url string) string <span class="cov8" title="1">{
  return fmt.Sprintf("%v%v", s.BaseUrl, strings.Replace(url, ":sessionid", s.SessionID, -1))
}</span>

// // POST  /session/:sessionId/back
// //
// // https://code.google.com/p/selenium/wiki/JsonWireProtocol#/session/:sessionId/back
// //
// // Navigate forwards in the browser history, if possible.
// //
// func (s *Wire) Back() (wireResponse *WireResponse, err error) {

//   var req *http.Request
//   if req, err = s.PostRequest("/session/:sessionid/back", nil); err == nil {

//     wireResponse, err = s.Do(req)

//   }

//   return wireResponse, err
// }

// Closes all of the active sessions.
func (s *Wire) CloseSessions() *Wire <span class="cov8" title="1">{

  for _, v := range s.Sessions </span><span class="cov8" title="1">{
    v.DeleteSession()
  }</span>

  <span class="cov8" title="1">return s</span>
}

// // GET /session/:sessionId/cookie
// //
// // https://code.google.com/p/selenium/wiki/JsonWireProtocol#/session/:sessionId/cookie
// //
// // Retrieve all cookies visible to the current page.
// //
// func (s *Wire) Cookie() (wireResponse *WireResponse, err error) {

//   var req *http.Request
//   if req, err = s.GetRequest("/session/:sessionid/cookie", nil); err == nil {

//     wireResponse, err = s.Do(req)

//   }

//   return wireResponse, err
// }

// // DELETE /session/:sessionId/cookie/:name
// //
// // https://code.google.com/p/selenium/wiki/JsonWireProtocol#/session/:sessionId/cookie/:name
// //
// // Delete the cookie with the given name. This command should be a no-op if there is no such cookie visible to the current page.
// //
// func (s *Wire) DeleteCookie(name string) (wireResponse *WireResponse, err error) {

//   var req *http.Request
//   if req, err = s.DeleteRequest(fmt.Sprintf("/session/:sessionid/cookie/%v", name), nil); err == nil {

//     wireResponse, err = s.Do(req)

//   }

//   return wireResponse, err
// }

// // DELETE /session/:sessionId/cookie
// //
// // https://code.google.com/p/selenium/wiki/JsonWireProtocol#/session/:sessionId/cookie
// //
// // Delete all cookies visible to the current page.
// //
// func (s *Wire) DeleteCookies() (wireResponse *WireResponse, err error) {

//   var req *http.Request
//   if req, err = s.DeleteRequest("/session/:sessionid/cookie", nil); err == nil {

//     wireResponse, err = s.Do(req)

//   }

//   return wireResponse, err
// }

// // POST /session/:sessionId/cookie
// //
// // https://code.google.com/p/selenium/wiki/JsonWireProtocol#/session/:sessionId/cookie
// //
// // Set a cookie. If the cookie path is not specified, it should be set to "/". Likewise, if the domain is omitted, it should default to the current page's domain.
// //
// func (s *Wire) SetCookie(value *Cookie) (wireResponse *WireResponse, err error) {

//   var req *http.Request
//   if req, err = s.PostRequest("/session/:sessionid/cookie", &amp;Params{"cookie": value}); err == nil {

//     wireResponse, err = s.Do(req)

//   }

//   return wireResponse, err
// }

// DELETE /session/:sessionid
//
// https://code.google.com/p/selenium/wiki/JsonWireProtocol#/session/:sessionId
//
// Delete the session.
//
func (s *Wire) DeleteSession() *Wire <span class="cov8" title="1">{

  var req *http.Request
  if req, s.Error = s.DeleteRequest("/session/:sessionid", nil); s.Error == nil </span><span class="cov8" title="1">{

    s.Response, s.Error = s.Do(req)

  }</span>

  <span class="cov8" title="1">return s</span>
}

// // GET /session/:sessionid
// //
// // https://code.google.com/p/selenium/wiki/JsonWireProtocol#/session/:sessionId
// //
// // Retrieve the capabilities of the specified session.
// //
// //    Returns:
// //    {object} An object describing the session's capabilities.
// func (s *Wire) GetSession() (wireResponse *WireResponse, err error) {

//   if req, err := s.GetRequest("/session/:sessionid", nil); err == nil {

//     wireResponse, err = s.Do(req)

//   }

//   return wireResponse, err
// }

// // POST  /session/:sessionId/forward
// //
// // https://code.google.com/p/selenium/wiki/JsonWireProtocol#/session/:sessionId/forward
// //
// // Navigate forwards in the browser history, if possible.
// //
// func (s *Wire) Forward() (wireResponse *WireResponse, err error) {

//   var req *http.Request
//   if req, err = s.PostRequest("/session/:sessionid/forward", nil); err == nil {

//     wireResponse, err = s.Do(req)

//   }

//   return wireResponse, err
// }

// // POST /session/:sessionId/keys
// //
// // https://code.google.com/p/selenium/wiki/JsonWireProtocol#/session/:sessionId/keys
// //
// // Send a sequence of key strokes to the active element. This command is similar to the send keys command in every aspect except the implicit termination: The modifiers are not released at the end of the call. Rather, the state of the modifier keys is kept between calls, so mouse interactions can be performed while modifier keys are depressed.
// //
// func (s *Wire) Keys(value []string) (wireResponse *WireResponse, err error) {

//   var req *http.Request
//   if req, err = s.PostRequest("/session/:sessionid/keys", &amp;Params{"value": value}); err == nil {

//     wireResponse, err = s.Do(req)

//   }

//   return wireResponse, err
// }

// // GET /session/:sessionId/location
// //
// // https://code.google.com/p/selenium/wiki/JsonWireProtocol#/session/:sessionId/location
// //
// // Get the current geo location.
// //
// func (s *Wire) Location() (wireResponse *WireResponse, err error) {

//   var req *http.Request
//   if req, err = s.GetRequest("/session/:sessionid/location", nil); err == nil {

//     wireResponse, err = s.Do(req)

//   }

//   return wireResponse, err
// }

// // POST /session/:sessionId/location
// //
// // https://code.google.com/p/selenium/wiki/JsonWireProtocol#/session/:sessionId/location
// //
// // Set the current geo location.
// //
// func (s *Wire) SetLocation(value *Location) (wireResponse *WireResponse, err error) {

//   var req *http.Request
//   if req, err = s.PostRequest("/session/:sessionid/location", &amp;Params{"location": value}); err == nil {

//     wireResponse, err = s.Do(req)

//   }

//   return wireResponse, err
// }

// // POST  /session/:sessionId/refresh
// //
// // https://code.google.com/p/selenium/wiki/JsonWireProtocol#/session/:sessionId/refresh
// //
// // Refresh the current page.
// //
// func (s *Wire) Refresh() (wireResponse *WireResponse, err error) {

//   var req *http.Request
//   if req, err = s.PostRequest("/session/:sessionid/refresh", nil); err == nil {

//     wireResponse, err = s.Do(req)

//   }

//   return wireResponse, err
// }


// POST /session
//
// https://code.google.com/p/selenium/wiki/JsonWireProtocol#POST_/session
//
// See webdriver.NewSession() for more detail.
//
// Creates a new session for a Client.  An JsonWireProtocol call is made
// to establish a session with a server.  The new session is added to the
// list of active sessions and returned to the caller.
//
// Capabilities are optional, however, it you define them, then, you must
// pass them in a specific order to this method.  Desired first, then, Required.
// Capabilities are currently implemented as a simple map and quite frankly
// I high doubt there will be much need to even support passing capabilities.
// However, it is in the spec, so, there is minimal support for it.
//
//      session, err := client.NewSession(
//               &amp;webdriver.Capabilities{"Platform": "Linux"}, // desired
//               &amp;webdriver.Capabilities{})                    // required
//
// When a new session is created, the server will return the actual capabilities
// currently supported.  An ActualCapabilities struct is created and attached
// to the returned session.
func (s *Wire) Session(values ...*Capabilities) (session *Session, err error) <span class="cov8" title="1">{

  // capabilities are optioinal to the newSession method, but,
  // not optional to the server.
  // desired needs to be first in line, then, required.
  // know a better way?  I'm all ears...
  capabilities := map[string]*Capabilities{
    "desiredCapabilities": &amp;Capabilities{},
    "requiredCapabilities": &amp;Capabilities{},
  }

  if len(values) &gt; 0 &amp;&amp; values[0] != nil </span><span class="cov8" title="1">{
    capabilities["desiredCapabilities"] = values[0]
  }</span>

  <span class="cov8" title="1">if len(values) &gt; 1 &amp;&amp; values[1] != nil </span><span class="cov8" title="1">{
    capabilities["requiredCapabilities"] = values[1]
  }</span>

  <span class="cov8" title="1">var req *http.Request
  if req, s.Error = s.PostRequest("/session", capabilities); s.Error == nil </span><span class="cov8" title="1">{

    if s.Response, s.Error = s.Do(req); s.Success() </span><span class="cov8" title="1">{

      // seems like everything went as planned.
      // create a new session and initialize it.
      session = &amp;Session{}
      session.Wire = &amp;Wire{}

      // setting the BaseUrl on the session is critical for http requests
      session.BaseUrl = s.BaseUrl

      // the Session ID returned during the API call.
      session.SessionID = s.Response.SessionID

      // extract the actual capabilities from the response and attach
      // them to the session
      actualCapabilities := &amp;ActualCapabilities{}
      if s.Error = json.Unmarshal(s.Response.Value, actualCapabilities); s.Error == nil </span><span class="cov8" title="1">{

        session.ActualCapabilities = actualCapabilities

        // add the newly created session to the list of sessions
        s.Sessions = append(s.Sessions, session)

      }</span>

    }

  }

  <span class="cov8" title="1">return session, s.Error</span>
}

// // GET /sessions
// //
// // https://code.google.com/p/selenium/wiki/JsonWireProtocol#/sessions
// //
// // Returns a list of the currently active sessions. Each session will be returned as a list of JSON objects with the following keys:
// //
// //    Key              Type      Description
// //    id               string    The session ID.
// //    capabilities     object    An object describing the session's capabilities.
// //
// //    Returns:
// //    {Array.&lt;Object&gt;} A list of the currently active sessions.
// func (s *Wire) Sessions() (wireResponse *WireResponse, err error) {

//   if req, err := s.GetRequest("/sessions", nil); err == nil {

//     wireResponse, err = s.Do(req)

//   }

//   return wireResponse, err
// }

// // GET /session/:sessionId/source
// //
// // https://code.google.com/p/selenium/wiki/JsonWireProtocol#GET_/session/:sessionId/source
// //
// // Get and return the browser's current page source as HTML.
// // wireResponse.StringValue() will contain the entire source as HTML.
// //
// // Source will return a wireResponse struct.  Value will contain a json.RawMessage value
// // returned from the server.  Firefox and chrome return different encodings, so, the raw
// // bytes are left "as is" from the server.  You can use wireResponse.UnmarshalValue() to attempt
// // to decode the value into a normal string.
// func (s *Wire) Source() (wireResponse *WireResponse, err error) {

//   if req, err := s.GetRequest("/session/:sessionid/source", nil); err == nil {

//     wireResponse, err = s.Do(req)

//   }

//   return wireResponse, err
// }

// GET /status
//
// https://code.google.com/p/selenium/wiki/JsonWireProtocol#GET_/status
//
// Query the status of the webdriver server.
// func (s *Wire) Status() (wireResponse *WireResponse, err error) {
func (s *Wire) Status() *Wire <span class="cov8" title="1">{

  var req *http.Request
  if req, s.Error = s.GetRequest("/status", nil); s.Error == nil </span><span class="cov8" title="1">{

    s.Response, s.Error = s.Do(req)

  }</span>

  <span class="cov8" title="1">return s</span>
}

// Extracts a WireResponse.Value as a string.
func (s *Wire) StringValue() (value string, err error) <span class="cov8" title="1">{

  if s.Success() &amp;&amp; s.Response.Value != nil </span><span class="cov8" title="1">{
    value = string(bytes.Trim(s.Response.Value, "{}\""))
  }</span>

  <span class="cov8" title="1">return value, s.Error</span>
}

// Checks the values of the response from a webdriver server.  If the
// http response code is 200 and the Status from the webdriver is 0, then,
// the request is considered successful.
func (s *Wire) Success() bool <span class="cov8" title="1">{
  return s.Error == nil &amp;&amp; s.Response.HttpStatusCode == 200 &amp;&amp; s.Response.Status == 0
}</span>

// GET /session/:sessionId/title
//
// https://code.google.com/p/selenium/wiki/JsonWireProtocol#GET_/session/:sessionId/title
//
// Get the current page title.
func (s *Wire) Title() *Wire <span class="cov8" title="1">{

  var req *http.Request
  if req, s.Error = s.GetRequest("/session/:sessionid/title", nil); s.Error == nil </span><span class="cov8" title="1">{

    s.Response, s.Error = s.Do(req)

  }</span>

  <span class="cov8" title="1">return s</span>
}

// POST  /session/:sessionId/url
//
// https://code.google.com/p/selenium/wiki/JsonWireProtocol#/session/:sessionId/url
//
// Navigate to a new URL.
//
// Browser should navigate to the given url.  url is any valid http url
// that you would normally enter in a browser.
// 
//      url - {string} The URL to navigate to.
func (s *Wire) Url(url string) *Wire <span class="cov8" title="1">{

  var req *http.Request
  if req, s.Error = s.PostRequest("/session/:sessionid/url", &amp;Params{"url": url}); s.Error == nil </span><span class="cov8" title="1">{

    s.Response, s.Error = s.Do(req)

  }</span>

  <span class="cov8" title="1">return s</span>
}

</pre>
		
		<pre class="file" id="file3" style="display: none">package webdriver

import (
  "bytes"
  "encoding/json"
  "fmt"
  "io/ioutil"
  "net/http"
)

// Convenience method that wraps NewRequest()
func (s *Wire) DeleteRequest(url string, payload interface{}) (req *http.Request, err error) <span class="cov8" title="1">{
  return s.NewRequest("DELETE", url, payload)
}</span>

// Convenience method that wraps NewRequest()
func (s *Wire) GetRequest(url string, payload interface{}) (req *http.Request, err error) <span class="cov8" title="1">{
  return s.NewRequest("GET", url, payload)
}</span>

// Convenience method that wraps NewRequest()
func (s *Wire) PostRequest(url string, payload interface{}) (req *http.Request, err error) <span class="cov8" title="1">{
  return s.NewRequest("POST", url, payload)
}</span>

// Constructs a new http.Request for the defined method and url including
// a payload.  Default http headers required by JsonWireProtocol are added
// for you based on the type of method (GET, POST, etc.)
//
// method - The type of request GET, POST, etc.
//
// url - The url of the request without the host and port.
// Host, port, and session id are included automatically.
//
// payload - JSON values to be included in the request.
//
func (s *Wire) NewRequest(method string, url string, payload interface{}) (req *http.Request, err error) <span class="cov8" title="1">{

  var body []byte

  if payload == nil </span><span class="cov8" title="1">{
    payload = map[string]interface{}{}
  }</span>

  <span class="cov8" title="1">if body, err = json.Marshal(payload); err == nil </span><span class="cov8" title="1">{

    if req, err = http.NewRequest(method, s.BuildFullUrl(url), bytes.NewBuffer(body)); err == nil </span><span class="cov8" title="1">{

      req.Header.Set("Accept", "application/json")
      req.Header.Set("Accept-charset", "utf-8")

      if method == "POST" || method == "DELETE" </span><span class="cov8" title="1">{
        req.Header.Add("Content-Type", "application/json;charset=utf-8")
      }</span>

    }
  }

  <span class="cov8" title="1">return req, err</span>
}

// Submits a request to a JsonWireProtocol server (selenium webdriver)
// and reads the response back into a WireResponse if the server
// responds with status code 200.
func (s *Wire) Do(req *http.Request) (wireResponse *WireResponse, err error) <span class="cov8" title="1">{

  // never be nil
  wireResponse = &amp;WireResponse{}

  var resp *http.Response
  if resp, err = http.DefaultClient.Do(req); err == nil </span><span class="cov8" title="1">{

    fmt.Println("status: ", resp.StatusCode)

    wireResponse.HttpStatusCode = resp.StatusCode

    // looking at the code for the Do method of the DefaultClient in the
    // http package.  It looks like I shouldn't have to be concerned with
    // redirects as it appears to handle them.
    if resp.StatusCode == 200 </span><span class="cov8" title="1">{

      var buffer []byte
      if buffer, err = ioutil.ReadAll(resp.Body); err == nil </span><span class="cov8" title="1">{

        err = json.Unmarshal(buffer, wireResponse)

      }</span>
    }
  }

  <span class="cov8" title="1">return wireResponse, err</span>
}


























</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible = document.getElementById('file0');
		files.addEventListener('change', onChange, false);
		function onChange() {
			visible.style.display = 'none';
			visible = document.getElementById(files.value);
			visible.style.display = 'block';
			window.scrollTo(0, 0);
		}
	})();
	</script>
</html>
